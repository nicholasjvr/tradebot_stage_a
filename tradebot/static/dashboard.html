<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tradebot – SQL to charts</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    * { box-sizing: border-box; }
    body { font-family: system-ui, sans-serif; margin: 0; padding: 1rem; background: #1a1a2e; color: #eee; }
    h1 { margin-top: 0; }
    .controls { margin-bottom: 1.5rem; display: flex; gap: 1rem; flex-wrap: wrap; align-items: center; }
    .controls label { display: flex; align-items: center; gap: 0.5rem; }
    .controls input, .controls select { padding: 0.4rem 0.6rem; border-radius: 6px; border: 1px solid #444; background: #2a2a3e; color: #eee; }
    .controls button { padding: 0.5rem 1rem; border-radius: 6px; border: none; background: #4361ee; color: white; cursor: pointer; }
    .controls button:hover { background: #3651d4; }
    .chart-wrap { background: #16213e; border-radius: 10px; padding: 1rem; margin-bottom: 1.5rem; max-width: 900px; }
    .chart-wrap h2 { margin: 0 0 0.5rem 0; font-size: 1rem; color: #a0a0c0; }
    .chart-container { position: relative; height: 280px; }
    .error { color: #ff6b6b; margin-top: 0.5rem; }
    .loading { color: #aaa; }
    .sql-ref { margin: 0 0 0.5rem 0; color: #888; font-size: 0.9rem; }
    .sql-ref code { font-size: 0.85rem; }
    table { width: 100%; border-collapse: collapse; margin-top: 0.5rem; font-size: 0.85rem; }
    th, td { text-align: left; padding: 0.35rem 0.5rem; border-bottom: 1px solid #333; }
    th { color: #a0a0c0; font-weight: 600; }
    .data-table-wrap { overflow-x: auto; max-height: 220px; overflow-y: auto; }
  </style>
</head>
<body>
  <h1>Tradebot – SQL → Charts</h1>
  <p>Charts are built from your API, which runs SQL against <code>marketdata.sqlite</code>.</p>

  <div class="chart-wrap">
    <h2>OHLCV close price (from <code>/ohlcv</code>)</h2>
    <div class="controls">
      <label>Symbol <select id="symbol"><option value="BTC/USDT">BTC/USDT</option></select></label>
      <label>Limit <select id="limit"><option value="50">50</option><option value="100" selected>100</option><option value="200">200</option><option value="500">500</option></select></label>
      <button id="loadOhlcv">Load &amp; chart</button>
    </div>
    <div class="chart-container"><canvas id="ohlcvChart"></canvas></div>
    <div id="ohlcvError" class="error"></div>
  </div>

  <div class="chart-wrap">
    <h2>Candle counts per symbol/timeframe (from <code>/chart/candle_counts</code>)</h2>
    <p class="sql-ref">SQL: <code>SELECT symbol, timeframe, COUNT(*) FROM ohlcv GROUP BY symbol, timeframe</code></p>
    <div class="chart-container"><canvas id="countsChart"></canvas></div>
    <div id="countsError" class="error"></div>
  </div>

  <div class="chart-wrap">
    <h2>Recent orders (from <code>/chart/orders</code>)</h2>
    <p class="sql-ref">SQL: <code>SELECT id, mode, symbol, side, type, status, amount, price, filled, ts, created_at FROM orders ORDER BY ts DESC LIMIT 15</code></p>
    <div class="chart-container"><canvas id="ordersChart"></canvas></div>
    <div class="data-table-wrap"><table id="ordersTable"><thead><tr><th>id</th><th>mode</th><th>symbol</th><th>side</th><th>type</th><th>status</th><th>amount</th><th>price</th><th>filled</th><th>ts</th></tr></thead><tbody></tbody></table></div>
    <div id="ordersError" class="error"></div>
  </div>

  <div class="chart-wrap">
    <h2>Recent fills (from <code>/chart/fills</code>)</h2>
    <p class="sql-ref">SQL: <code>SELECT f.id, f.symbol, f.side, f.price, f.amount, f.cost, f.ts, f.order_id FROM fills f ORDER BY f.ts DESC LIMIT 10</code></p>
    <div class="data-table-wrap"><table id="fillsTable"><thead><tr><th>id</th><th>symbol</th><th>side</th><th>price</th><th>amount</th><th>cost</th><th>ts</th><th>order_id</th></tr></thead><tbody></tbody></table></div>
    <div id="fillsError" class="error"></div>
  </div>

  <div class="chart-wrap">
    <h2>Current positions (from <code>/chart/positions</code>)</h2>
    <p class="sql-ref">SQL: <code>SELECT mode, exchange, symbol, base_qty, avg_entry_price, realized_pnl, updated_at FROM positions ORDER BY symbol</code></p>
    <div class="chart-container"><canvas id="positionsChart"></canvas></div>
    <div class="data-table-wrap"><table id="positionsTable"><thead><tr><th>mode</th><th>exchange</th><th>symbol</th><th>base_qty</th><th>avg_entry_price</th><th>realized_pnl</th><th>updated_at</th></tr></thead><tbody></tbody></table></div>
    <div id="positionsError" class="error"></div>
  </div>

  <script>
    const apiBase = ''; // same origin as the page

    // OHLCV line chart
    let ohlcvChart = null;
    document.getElementById('loadOhlcv').addEventListener('click', loadOhlcv);
    async function loadOhlcv() {
      const symbol = document.getElementById('symbol').value;
      const limit = document.getElementById('limit').value;
      const errEl = document.getElementById('ohlcvError');
      errEl.textContent = 'Loading…';
      try {
        const r = await fetch(apiBase + '/ohlcv?symbol=' + encodeURIComponent(symbol) + '&limit=' + limit);
        if (!r.ok) throw new Error(await r.text());
        const data = await r.json();
        if (!data.length) { errEl.textContent = 'No data for ' + symbol; return; }
        const sorted = data.slice().sort((a, b) => a.timestamp - b.timestamp);
        const labels = sorted.map(row => new Date(row.timestamp).toLocaleString());
        const closes = sorted.map(row => row.close);

        if (!ohlcvChart) {
          ohlcvChart = new Chart(document.getElementById('ohlcvChart'), {
            type: 'line',
            data: { labels, datasets: [{ label: 'Close', data: closes, borderColor: '#4361ee', tension: 0.1, fill: false }] },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: { legend: { labels: { color: '#eee' } } },
              scales: {
                x: { ticks: { color: '#aaa', maxTicksLimit: 10 } },
                y: { ticks: { color: '#aaa' } }
              }
            }
          });
        } else {
          ohlcvChart.data.labels = labels;
          ohlcvChart.data.datasets[0].data = closes;
          ohlcvChart.data.datasets[0].label = 'Close – ' + symbol;
          ohlcvChart.update();
        }
        errEl.textContent = '';
      } catch (e) {
        errEl.textContent = 'Error: ' + e.message;
      }
    }

    // Candle counts bar chart (from predefined SQL)
    (async function loadCandleCounts() {
      const errEl = document.getElementById('countsError');
      errEl.textContent = 'Loading…';
      try {
        const r = await fetch(apiBase + '/chart/candle_counts');
        if (!r.ok) throw new Error(await r.text());
        const data = await r.json();
        if (!data.length) { errEl.textContent = 'No data.'; return; }
        const labels = data.map(row => row.symbol + ' ' + row.timeframe);
        const counts = data.map(row => row.candle_count);

        new Chart(document.getElementById('countsChart'), {
          type: 'bar',
          data: {
            labels,
            datasets: [{ label: 'Candles', data: counts, backgroundColor: '#4361ee88' }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { labels: { color: '#eee' } } },
            scales: {
              x: { ticks: { color: '#aaa' } },
              y: { ticks: { color: '#aaa' } }
            }
          }
        });
        errEl.textContent = '';
      } catch (e) {
        errEl.textContent = 'Error: ' + e.message;
      }
    })();

    // Orders: bar chart by status + table
    (async function loadOrders() {
      const errEl = document.getElementById('ordersError');
      const tbody = document.querySelector('#ordersTable tbody');
      errEl.textContent = 'Loading…';
      try {
        const r = await fetch(apiBase + '/chart/orders?limit=15');
        if (!r.ok) throw new Error(await r.text());
        const data = await r.json();
        errEl.textContent = '';
        const byStatus = {};
        data.forEach(row => { byStatus[row.status] = (byStatus[row.status] || 0) + 1; });
        const statusLabels = Object.keys(byStatus);
        const statusCounts = statusLabels.map(s => byStatus[s]);
        if (statusLabels.length) {
          if (window.ordersChart) window.ordersChart.destroy();
          window.ordersChart = new Chart(document.getElementById('ordersChart'), {
            type: 'bar',
            data: { labels: statusLabels, datasets: [{ label: 'Orders', data: statusCounts, backgroundColor: '#4361ee88' }] },
            options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { labels: { color: '#eee' } } }, scales: { x: { ticks: { color: '#aaa' } }, y: { ticks: { color: '#aaa' } } } }
          });
        }
        tbody.innerHTML = data.length ? data.map(row => `<tr><td>${row.id}</td><td>${row.mode}</td><td>${row.symbol}</td><td>${row.side}</td><td>${row.type}</td><td>${row.status}</td><td>${row.amount != null ? row.amount : ''}</td><td>${row.price != null ? row.price : ''}</td><td>${row.filled != null ? row.filled : ''}</td><td>${row.ts != null ? new Date(row.ts).toLocaleString() : ''}</td></tr>`).join('') : '<tr><td colspan="10">No orders</td></tr>';
      } catch (e) {
        errEl.textContent = 'Error: ' + e.message;
      }
    })();

    // Fills: table only
    (async function loadFills() {
      const errEl = document.getElementById('fillsError');
      const tbody = document.querySelector('#fillsTable tbody');
      errEl.textContent = 'Loading…';
      try {
        const r = await fetch(apiBase + '/chart/fills?limit=10');
        if (!r.ok) throw new Error(await r.text());
        const data = await r.json();
        errEl.textContent = '';
        tbody.innerHTML = data.length ? data.map(row => `<tr><td>${row.id}</td><td>${row.symbol}</td><td>${row.side}</td><td>${row.price}</td><td>${row.amount}</td><td>${row.cost}</td><td>${row.ts != null ? new Date(row.ts).toLocaleString() : ''}</td><td>${row.order_id != null ? row.order_id : ''}</td></tr>`).join('') : '<tr><td colspan="8">No fills</td></tr>';
      } catch (e) {
        errEl.textContent = 'Error: ' + e.message;
      }
    })();

    // Positions: bar chart by symbol (realized_pnl) + table
    (async function loadPositions() {
      const errEl = document.getElementById('positionsError');
      const tbody = document.querySelector('#positionsTable tbody');
      errEl.textContent = 'Loading…';
      try {
        const r = await fetch(apiBase + '/chart/positions');
        if (!r.ok) throw new Error(await r.text());
        const data = await r.json();
        errEl.textContent = '';
        if (data.length) {
          if (window.positionsChart) window.positionsChart.destroy();
          const labels = data.map(row => row.symbol);
          const pnl = data.map(row => row.realized_pnl != null ? row.realized_pnl : 0);
          window.positionsChart = new Chart(document.getElementById('positionsChart'), {
            type: 'bar',
            data: { labels, datasets: [{ label: 'Realized PnL', data: pnl, backgroundColor: pnl.map(v => v >= 0 ? '#22c55e88' : '#ef444488') }] },
            options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { labels: { color: '#eee' } } }, scales: { x: { ticks: { color: '#aaa' } }, y: { ticks: { color: '#aaa' } } } }
          });
        }
        tbody.innerHTML = data.length ? data.map(row => `<tr><td>${row.mode}</td><td>${row.exchange}</td><td>${row.symbol}</td><td>${row.base_qty}</td><td>${row.avg_entry_price != null ? row.avg_entry_price : ''}</td><td>${row.realized_pnl != null ? row.realized_pnl : ''}</td><td>${row.updated_at || ''}</td></tr>`).join('') : '<tr><td colspan="7">No positions</td></tr>';
      } catch (e) {
        errEl.textContent = 'Error: ' + e.message;
      }
    })();

    // Populate symbol dropdown from API, then load OHLCV
    (async function initSymbolDropdown() {
      const sel = document.getElementById('symbol');
      try {
        const r = await fetch(apiBase + '/chart/symbols');
        if (r.ok) {
          const symbols = await r.json();
          if (symbols.length) {
            sel.innerHTML = symbols.map(s => `<option value="${s}">${s}</option>`).join('');
            const hasBtc = symbols.includes('BTC/USDT');
            if (hasBtc) sel.value = 'BTC/USDT';
          }
        }
      } catch (_) {}
      loadOhlcv();
    })();
  </script>
</body>
</html>
